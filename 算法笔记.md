



## 第7课队列与栈

### 单调栈



## 第8课 分治与回溯

### 8.1 分治

分治代码模板:
recursion terminator
prepare data
conquer subproblems
process and generate the final result
revert the current level states
递归终止条件
拆分子问题
调子问题的递归函数
合并结果
恢复当前层状态
（当前层只考虑当前层 不要下探）

```python
# 普通递归Python
def recursion(level, param1, param2, ...): 
# recursion terminator 
if level > MAX_LEVEL: 
# process_result 
return 

# process logic in current level 
process(level, data...) 

# drill down 
self.recursion(level + 1, p1, ...) 

# reverse the current level status if needed

#分治递归代码
def divide_conquer(problem,param1,param2,,,)
  if problem is None;
    print result;
    return
#准备数据
  data=prepare_data(problem);
  subproblems=split_problem(problem,data);
subres0=self.divide_conquer(psubproblems[0],p1,p2,,,)
subres1=self.divide_conquer(psubproblems[1],p1,p2,,,)
result=process_result(subres0,subres1,,,)
```

### 8.2 回溯

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的工程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。

**回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：**

1. 找到一个可能存在的正确的答案。
2. 在尝试了所有可能的分步方法后宣告该问题没有答案。
    在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

## 第9课 深度遍历与广度遍历

### 9.1dfs

```c++

//C/C++

//递归写法：

map<int, int> visited;

void dfs(Node* root) {

 // terminator

 if (!root) return ;

 if (visited.count(root->val)) {

  // already visited

  return ;

 }

 visited[root->val] = 1;

 // process current node here. 

 // ...

 for (int i = 0; i < root->children.size(); ++i) {

  dfs(root->children[i]);

 }

 return ;

}

//非递归写法：

void dfs(Node* root) {

 map<int, int> visited;

 if(!root) return ;

 stack<Node*> stackNode;

 stackNode.push(root);

 while (!stackNode.empty()) {

  Node* node = stackNode.top();

  stackNode.pop();

  if (visited.count(node->val)) continue;

  visited[node->val] = 1;

  for (int i = node->children.size() - 1; i >= 0; --i) {

​    stackNode.push(node->children[i]);

  }

 }

 return ;

}
```

### 9.2bfs

```c++
// C/C++

void bfs(Node* root) {

 map<int, int> visited;

 if(!root) return ;

 queue<Node*> queueNode;

 queueNode.push(root);

 while (!queueNode.empty()) {

  Node* node = queueNode.top();

  queueNode.pop();

  if (visited.count(node->val)) continue;

  visited[node->val] = 1;

  for (int i = 0; i < node->children.size(); ++i) {

​    queueNode.push(node->children[i]);

  }

 }

 return ;

}
```

