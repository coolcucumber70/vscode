



## 第8课 分治与回溯

8.1 分治



## 第9课 深度遍历与广度遍历

### 9.1dfs

```c++

//C/C++

//递归写法：

map<int, int> visited;

void dfs(Node* root) {

 // terminator

 if (!root) return ;

 if (visited.count(root->val)) {

  // already visited

  return ;

 }

 visited[root->val] = 1;

 // process current node here. 

 // ...

 for (int i = 0; i < root->children.size(); ++i) {

  dfs(root->children[i]);

 }

 return ;

}

//非递归写法：

void dfs(Node* root) {

 map<int, int> visited;

 if(!root) return ;

 stack<Node*> stackNode;

 stackNode.push(root);

 while (!stackNode.empty()) {

  Node* node = stackNode.top();

  stackNode.pop();

  if (visited.count(node->val)) continue;

  visited[node->val] = 1;

  for (int i = node->children.size() - 1; i >= 0; --i) {

​    stackNode.push(node->children[i]);

  }

 }

 return ;

}
```

### 9.2bfs

```c++
// C/C++

void bfs(Node* root) {

 map<int, int> visited;

 if(!root) return ;

 queue<Node*> queueNode;

 queueNode.push(root);

 while (!queueNode.empty()) {

  Node* node = queueNode.top();

  queueNode.pop();

  if (visited.count(node->val)) continue;

  visited[node->val] = 1;

  for (int i = 0; i < node->children.size(); ++i) {

​    queueNode.push(node->children[i]);

  }

 }

 return ;

}
```

